---
title: "Assignment 1"
author: "Yasamin Nouri Jelyani"
output:
  html_document:
    toc: true
    toc_depth: 2
    df_print: paged
bibliography: a2.bib
csl: biomed-central.csl
nocite: '@*'
---

# Introduction

Women of African American (AA) ancestry are know to have more risk of being 
diagnosed
with ER-/TN(triple negative) breast cancer, as compared to women in European 
American (EA) ancestry. This study looks at a number of differentially expressed 
microRNA (DEmiRs) to identify miRNA patterns that are potential biomarkers 
of this disease. This study found that out of the 102 ER-subtype related DemiRs, majority 
of them were specific to the race, and only 23 were common between the races (1).
Hence, there are subsets of microRNA that are differentially expressed between EA and
AA women. This information help with better targetted treatment of this type of cancer.

Tissue samples:
58 Breast cancer patient (29 AA, 29 EA)
10 healthy women (5 AA, 5 EA)
<br/>
**Question1: What are the control and test conditions of the dataset?** <br/> 
Control condition: Healthy female breast tissue, for both AA and EA decent individuals <br/> 

test condition: Breast cancer breast tissue for both ER+ and ER- cancer types
and for for AA and EA decent patients.
<br/>

**Question2: Why us the dataset of interest to you?** <br/> 
 Since breast cancer has disproportionately effected the individuals from
 the african american decent in the clinic, it is interesting for 
 me to know the reason for this increased vulnerability to breast cancer 
 in this population. This study helps clearify the effect of differentially expressed
 microRNA among the AA and EA population. This information will help guide treatment 
 and prognosis in the clinic. <br/>
 
 
# Find duplicated genes

# Download the Data
First, I downloaded the GEOmetaDB, and got access to the meta data:
```{r eval=FALSE}

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if (!requireNamespace("GEOmetadb", quietly = TRUE))
    BiocManager::install("GEOmetadb")

if(!requireNamespace("knitr", quietly=TRUE))
  install.packages("knitr")

if(! requireNamespace("edgeR", quietly=TRUE))
  BiocManager::install("edgeR")

if (!requireNamespace("GEOquery", quietly=TRUE))
  BiocManager::install("GEOquery")

if (!requireNamespace("biomaRt", quietly = TRUE)){
  install.packages("biomaRt")}

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

if (!require("BiocManager", quietly = TRUE))
  BiocManager::install("mirbase.db")


library(GEOmetadb)
library(biomaRt)
library(mirbase.db)


if( !file.exists("GEOmetadb.sqlite") ) {
    demo_sqlfile <- getSQLiteFile(destdir = getwd(), destfile = "GEOmetadb.sqlite.gz", type = "demo")
} else {
    demo_sqlfile <- "GEOmetadb.sqlite"
    
}

file.info(demo_sqlfile)

con <- dbConnect(SQLite(), demo_sqlfile)

```

Query of the database:
```{r eval=FALSE}
sql <- paste("SELECT DISTINCT gse.title,gse.gse, gpl.title,",
             " gse.submission_date,",
             " gse.supplementary_file", #<<
             "FROM",
             "  gse JOIN gse_gpl ON gse_gpl.gse=gse.gse",
             "  JOIN gpl ON gse_gpl.gpl=gpl.gpl",
             "WHERE",
             "  gse.submission_date > '2017-01-01' AND",
             "  gse.title LIKE '%breast%' AND", 
             "  gpl.organism LIKE '%Homo sapiens%' AND",
             "  gpl.technology LIKE '%high-throughput sequencing%' ",
             "  ORDER BY gse.submission_date DESC",sep=" ")

rs <- dbGetQuery(con,sql)
counts_files <- rs$supplementary_file[grep(rs$supplementary_file,
                              pattern = "count|cnt",ignore.case = TRUE)]

series_of_interest <- rs$gse[grep(rs$supplementary_file,
                              pattern = "count|cnt",ignore.case = TRUE)]

shortened_filenames <- unlist(lapply(counts_files,
              FUN = function(x){x <- unlist(strsplit(x,";")) ;
              x <- x[grep(x,pattern= "count|cnt",ignore.case = TRUE)];
                tail(unlist(strsplit(x,"/")),n=1)}))
shortened_filenames[1:10]
rs <- dbGetQuery(con,sql)
knitr::kable(rs, format = "html")

```

Open the data:
```{r message=FALSE}
sfiles = GEOquery::getGEOSuppFiles('GSE117452')

#if the file exists, open it
fnames <- "GSE117452/GSE117452_expn_matrix_mimat.txt.gz"
if (! file.exists(fnames)){
  gse <- GEOquery::getGEO("GSE117452", GSEMatrix=FALSE)
  sfiles = GEOquery::getGEOSuppFiles("GSE117452")
  fnames = rownames(sfiles)
}
```





## Geo Description of dataset:
```{r message=FALSE}
gse <- GEOquery::getGEO("GSE117452",GSEMatrix=FALSE)

knitr::kable(data.frame(head(GEOquery::Meta(gse))), format = "html")
```

Platform title:
```{r warning=FALSE}
current_gpl <- names(GEOquery::GPLList(gse))[1]
current_gpl_info <- GEOquery::Meta(GEOquery::getGEO(current_gpl))
```


**Platform title:** `r current_gpl_info$title`<br /> **Submission data:**`r current_gpl_info$submission_date` <br/> **Last Update data:** `r current_gpl_info$last_update_date` <br/> **Organism:** `r current_gpl_info$organism` <br/> **Number of GEO datasets using this technology:** `r length(current_gpl_info$series_id)` <br/> **Number of GEO samples that use this technology:**`r length(current_gpl_info$sample_id)`<br/>


Getting the expression data
```{r message=FALSE}
sfiles = GEOquery::getGEOSuppFiles('GSE117452')

fnames = rownames(sfiles)

#69 columns, there are 68 samples (58 breast cancer patients 
#(29 AA and 29 EA women) and 10 (5 AA and 5 EA) healthy women.)

#589 rows (Genes) differentially expressed microRNA


er_exp = read.delim(fnames[1],header=TRUE, check.names = FALSE) #not correct col names


knitr::kable(er_exp[1:5,1:10], format = "html")
```

cleaning the data
```{r}
dim(er_exp)

colnames(er_exp)
```

#Assess the data:
The data does not have duplicates.
```{r}
num_samples <- dim(er_exp)[2] - 1 # The number of rows correspond to the number of columns minus 1 for the gene name colummn 68
num_genes <- dim(er_exp)[1] # The number of genes analysed 2576 genes from the microRNA
num_unique_genes <- length(unique(er_exp$Gene)) # How many unique genes are measured: 2576
num_lack_identifier <- sum(is.na(er_exp$Gene)) # How many rows do not have an gene identifier: 0

```

There are no repetative genes.

```{r}
summarized_gene_counts <- sort(table(er_exp$Gene),
                               decreasing = TRUE)
```

From this information we see that there are no repeated genes in the dataset.
**Question3: Were there expression values that were not unique for specific genes? How did you handle these?** <br/> 
 All genes had a unique expression value. As seen in the decreasing frequency table
 for all of the genes, all genes had a frequency of 1. 
 <br/> 
 **Question6: How did you handle replicates?** <br/> 
 Since there were no replicates, this was not an issue with my dataset. 

```{r}
knitr::kable(table(er_exp$Gene)[1:3], format="html")
```
# Normalization:

```{r}
#translate out counts into counts per million using 
#the edgeR package function cpm
cpms = edgeR::cpm(er_exp[,2:ncol(er_exp)])
rownames(cpms) <- er_exp[,1]
# get rid of low counts to remove potential outliers
keep = rowSums(cpms >1) >=10 # 10 is the min number of samples in healthy group
er_exp_filtered = er_exp[keep,]
```


We removed the potential outliers, now we have only 810 out of the 
original, pre-filtered 2576 genes to analyse.
<br/>
**Question5: How many outliers were removed?** <br/>
There were 1766 outliers removed from the data.
<br/>
**Question7: What is the final coverage of your dataset?** <br/>
The final coverage is with 810 genes, after filtering. 


```{r}

dim(er_exp)
dim(er_exp_filtered)
```

From the paper, we know that there were a total of 68 samples.
10 of these samples were from healthy individuals. These are the 
last 10 columns. The first column is the gene names that are anlysed. 
The next 58 columns are randomised patient count data.

```{r}
colnames(er_exp_filtered)

```

## Boxplot after normalization

```{r warning=FALSE}
# do not have space for all 
data2plot <- log2(edgeR::cpm(er_exp_filtered[,2:20]))
boxplot(data2plot, xlab = "Samples", ylab = "log2 CPM", 
        las = 2, cex = 0.5, cex.lab = 0.5,
        cex.axis = 0.5, main = "ER RNASeq Samples")
#draw the median on each box plot
abline(h = median(apply(data2plot, 2, median)), 
       col = "green", lwd = 0.6, lty = "dashed")
```

## Boxplot before normalization


```{r warning=FALSE}
# do not have space for all 
data2plot <- log2(edgeR::cpm(er_exp[,2:20]))
boxplot(data2plot, xlab = "Samples", ylab = "log2 CPM", 
        las = 2, cex = 0.5, cex.lab = 0.5,
        cex.axis = 0.5, main = "ER RNASeq Samples")
#draw the median on each box plot
abline(h = median(apply(data2plot, 2, median)), 
       col = "green", lwd = 0.6, lty = "dashed")
```



## Density plot after normalization

The dataset looks approximately normal. Hence, it can be approximated as a normal distribution.
I have plotted the control and patient data 
seperately. 

Patient Data:
```{r}
# the last 10 rows are healthy samples
end <- ncol(er_exp) - 11
counts_density <- apply(log2(edgeR::cpm(er_exp_filtered[,2:end])), 
                        2, density)
  #calculate the limits across all the samples
    xlim <- 0; ylim <- 0
    for (i in 1:length(counts_density)) {
      xlim <- range(c(xlim, counts_density[[i]]$x)); 
      ylim <- range(c(ylim, counts_density[[i]]$y))
    }
    cols <- rainbow(length(counts_density))
    ltys <- rep(1, length(counts_density))
    #plot the first density plot to initialize the plot
    plot(counts_density[[1]], xlim=xlim, ylim=ylim, type="n", 
         ylab="Smoothing density of log2-CPM", 
         main="", cex.lab = 0.85)
    #plot each line
    for (i in 1:length(counts_density)) 
      lines(counts_density[[i]], col=cols[i], lty=ltys[i])
    #create legend
    legend("topright", colnames(data2plot),  
           col=cols, lty=ltys, cex=0.75, 
           border ="blue",  text.col = "green4", 
           merge = TRUE, bg = "gray90")
```

Healthy control Data:
The last 10 columns are healthy data.

```{r}
start <- ncol(er_exp) - 10
counts_density <- apply(log2(edgeR::cpm(er_exp_filtered[,start:ncol(er_exp)])), 
                        2, density)
  #calculate the limits across all the samples
    xlim <- 0; ylim <- 0
    for (i in 1:length(counts_density)) {
      xlim <- range(c(xlim, counts_density[[i]]$x)); 
      ylim <- range(c(ylim, counts_density[[i]]$y))
    }
    cols <- rainbow(length(counts_density))
    ltys <- rep(1, length(counts_density))
    #plot the first density plot to initialize the plot
    plot(counts_density[[1]], xlim=xlim, ylim=ylim, type="n", 
         ylab="Smoothing density of log2-CPM", 
         main="", cex.lab = 0.85)
    #plot each line
    for (i in 1:length(counts_density)) 
      lines(counts_density[[i]], col=cols[i], lty=ltys[i])
    #create legend
    legend("topright", colnames(data2plot),  
           col=cols, lty=ltys, cex=0.75, 
           border ="blue",  text.col = "green4", 
           merge = TRUE, bg = "gray90")
```

```{r}
limma::plotMA(log2(er_exp[,c(3,4)]), ylab="M - ratio log expression", 
       main="ER - vs + example")
```
# Mapping

miRBase assigns each microRNA stem‐loop sequence a symbol in the format “mir‐#” and each mature miRNA a symbol in the format “miR‐#” followed by a unique sequential number that reflects order of submission to the database. The HGNC then approves a gene symbol for human miRNA genes in the format MIR#; for example, MIR17 represents the miRNA gene, mir‐17 represents the stem‐loop, and miR‐17 represents the mature miRNA.

https://www.genenames.org/about/guidelines/ 

https://www.mirbase.org/
<br/>

**Question4: Were there expression values that could not be mapped to current HUGO symbols?** 
Using the mirbase.db, the HUGO symbols can easily be mapped to the genes identified in this study. 




```{r}
library(biomaRt)
listMarts()

ensembl <- useMart("ensembl")
datasets <- listDatasets(ensembl)

ensembl <- useDataset("hsapiens_gene_ensembl",mart=ensembl)
dim(listFilters(ensembl))


```

#TODO: I did not know how to do this since my data was not ensembl:


```{r echo=FALSE}
#conversion_stash <- "ca125_id_conversion.rds"
#if(file.exists(conversion_stash)){
#  ca125_id_conversion <- readRDS(conversion_stash)
#} else {
#  ca125_id_conversion <- getBM(attributes = c("ensembl_gene_id","hgnc_symbol"),
#                            filters = c("ensembl_gene_id"),
#                            values = er_exp_filtered$ensembl75_id,
#                            mart = ensembl)
#  saveRDS(ca125_id_conversion, conversion_stash)
#}
```

```{r echo=FALSE}
#normalized_counts_annot <- merge(ca125_id_conversion,normalized_counts, by.x = 1, by.y = 0, all.y=TRUE)
                            
#kable(normalized_counts_annot[1:5,1:5],type = "html")
```

# Number of missing identifiers:

```{r echo=FALSE}
#ensembl_id_missing_gene <- normalized_counts_annot$ensembl_gene_id[
#  which(is.na(normalized_counts_annot$hgnc_symbol))]
#length(ensembl_id_missing_gene)
```




**Question7: What is the final coverage of your dataset?** <br /> In the final dataset, we 
have 

Disconnect from the database:
```{r eval=FALSE}

dbDisconnect(con)

```

# References

