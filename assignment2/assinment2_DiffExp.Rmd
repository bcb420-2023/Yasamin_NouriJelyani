---
title: "Assignment 1"
author: "Yasamin Nouri Jelyani"
output:
  html_document:
    toc: yes
    toc_depth: 2
    df_print: paged
  pdf_document:
    toc: yes
    toc_depth: '2'
bibliography: a2.bib
csl: "biomed-central.csl"
nocite: '@*'
---

# Introduction

RNA processing events include transcription, mRNA splicing, and Export.
These RNA processing events are coordinated by the TREX complex.
The essential subunit of the TREX complex is: DDX39B. This paper explores function of the DDX39B complex in handling damaged DNA.
The DDX39B complex couples the splicing and export events by recruiting ALYREF. The DDX39B complex also facilitates DNA repair.
It facilitated DNA repair by upregulating BRCA1 by binding to it, and stabalizing it.This	ensures ssDNA formation and RAD51 accumulation at double stranded break sites.
Hence, the DDX39B complex handles damaged DNA by maintaining BRCA1 levels. <\br>
Without DDX39B ovarian cancer cells have hypersensitivity to DNA-damaging chemotherapeutic and are more likely to have damaged DNA.
High DDX39B expression is correlated with worse survival in ovarian cancer patients since it protects the cells from DNA damage. 
DDX39B suppression represents a target for enhancing the efficacy of chemotherapy in BRCA1-proficient ovarian cancers. The paper has found that lacking DDX is like lacking BRCA1 which prevents the cells from repairing their broken DNA. <\br>
DDX39B depletion sensitizes cancer cells to DNA damaging agent including chemotherapy. The experiment in this paper used HeLA cells and performed Knockout of DDX39B complex genes on 3 knockout samples. The researchers then checked response to chemo agents. They discovered less survival as compared to wild type cells. <\b>
Following the loss of DDX39B, the researchers persormed transcriptome profiles. They preformed mRNA sequencing in both wild-type and DDX39B knockout HeLa cells. <\br>
Among the genes that are regulated by DDX39B deficiency, 1483 genes were found to be upregulated and 1272 genes were down-regulated. Importantly, BRCA1, which is a key player in DNA damage repair, was significantly downregulated in DDX39B-depleted cells. 

The researchers also performed qPCR and western blot to confirm that BRCA1 both the mRNA and protein levels were decreased in DDX39B knock out HeLa cells. Researchers also found that the regulation on BRCA1 is specific to DDX39B and no other DDX homologues.
All in all, these data suggest that DDX39B participates in DNA repair pathway via upregulating BRCA1 at the mRNA level. <\br>
KO: DDX knockout genes <\br>
WT: wild type <\br>

**Question1: What are the control and test conditions of the dataset?** <br/> 
Control condition: Healthy female breast tissue, for both AA and EA decent individuals <br/> 

test condition: Breast cancer breast tissue for both ER+ and ER- cancer types
and for for AA and EA decent patients.
<br/>

**Question2: Why us the dataset of interest to you?** <br/> 
 Since breast cancer has disproportionately effected the individuals from
 the african american decent in the clinic, it is interesting for 
 me to know the reason for this increased vulnerability to breast cancer 
 in this population. This study helps clearify the effect of differentially expressed
 microRNA among the AA and EA population. This information will help guide treatment 
 and prognosis in the clinic. <br/>
 
 
# Find duplicated genes

# Download the Data
First, I downloaded the GEOmetaDB, and got access to the meta data:
```{r eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if (!requireNamespace("GEOmetadb", quietly = TRUE))
    BiocManager::install("GEOmetadb")
if(!requireNamespace("knitr", quietly=TRUE))
  install.packages("knitr")
if(! requireNamespace("edgeR", quietly=TRUE))
  BiocManager::install("edgeR")
if (!requireNamespace("GEOquery", quietly=TRUE))
  BiocManager::install("GEOquery")
if (!requireNamespace("biomaRt", quietly = TRUE)){
  install.packages("biomaRt")}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if (!require("stringr", quietly = TRUE))
    install.packages("stringr")
if (!require("dplyr", quietly = TRUE))
    install.packages("dplyr")

if (!require("Biobase", quietly = TRUE))
    install.packages("Biobase")




library(GEOmetadb)
library(biomaRt)
if( !file.exists("GEOmetadb.sqlite") ) {
    demo_sqlfile <- getSQLiteFile(destdir = getwd(), destfile = "GEOmetadb.sqlite.gz", type = "demo")
} else {
    demo_sqlfile <- "GEOmetadb.sqlite"
    
}


```

```{r}
library(dplyr)
library(magrittr)
library(knitr)
library(Biobase)
```



Download the data:

```{r message=FALSE}
#if the file exists, open it
fnames <- "GSE156543/GSE156543_Raw_gene_counts_matrix.txt.gz"

if (! file.exists(fnames)){
  gse <- GEOquery::getGEO("GSE117452", GSEMatrix=FALSE)
  sfiles = GEOquery::getGEOSuppFiles("GSE156543")
  fnames = rownames(sfiles)
}
```


## Geo Description of dataset:
```{r message=FALSE}
gse <- GEOquery::getGEO("GSE156543",GSEMatrix=FALSE)
data.frame(head(GEOquery::Meta(gse)))
knitr::kable(data.frame(head(GEOquery::Meta(gse))), format = "html")
```

Platform title:
```{r warning=FALSE}
current_gpl <- names(GEOquery::GPLList(gse))[1]
current_gpl_info <- GEOquery::Meta(GEOquery::getGEO(current_gpl))
```


**Platform title:** `r current_gpl_info$title`<br /> **Submission data:**`r current_gpl_info$submission_date` <br/> **Last Update data:** `r current_gpl_info$last_update_date` <br/> **Organism:** `r current_gpl_info$organism` <br/> **Number of GEO datasets using this technology:** `r length(current_gpl_info$series_id)` <br/> **Number of GEO samples that use this technology:**`r length(current_gpl_info$sample_id)`<br/>


Getting the expression data 
```{r message=FALSE}
DDX39B_exp = read.delim(fnames[1],header=TRUE, check.names = FALSE) 

knitr::kable(DDX39B_exp[1:5,], format = "html")

```

cleaning the data:
I have unique ENSG IDs, so I will not filter
```{r}
dim(DDX39B_exp) 
#58381 rows, 6 col
colnames(DDX39B_exp) 
#(3 KO and 3 WT)

rownames(DDX39B_exp) 
if("ensemble_ID" %in% colnames(DDX39B_exp))
{
  ;
}else{
  DDX39B_exp <- tibble::rownames_to_column(DDX39B_exp, "VALUE")
  colnames(DDX39B_exp) <- c("ensemble_ID", "KO1", "KO2", "KO3", "WT1", "WT2", "WT3")

}

summarized_gene_counts <- sort(table(DDX39B_exp$ensemble_ID), decreasing = TRUE)
knitr::kable(table(DDX39B_exp[, 1])[1:3], format="html")

```


## Gene name structure
Removing genes that do not follow ensembl nomenclature

```{r}
#check that all ensg are unique and all start with ENSG pattern 
areUniquegenes <- length(DDX39B_exp$ensemble_ID) == length(unique(DDX39B_exp$ensemble_ID))
allValidGenes <- length(grep("ENSG.*", DDX39B_exp$ensemble_ID)) == length(DDX39B_exp$ensemble_ID)


```


In edgeR, it is recommended to remove features without at least 1 read per million
in n of the samples, where n is the size of the smallest group of replicates.

```{r}
#removing the versions  
DDX39B_exp <- tidyr::separate(DDX39B_exp, ensemble_ID, into = c("ensemble_ID", "Second"), "[.]")
DDX39B_exp <- DDX39B_exp[, -2]  
  
cpms = edgeR::cpm(DDX39B_exp[,2:7])
rownames(cpms) <- DDX39B_exp$ensembl_id
keep = rowSums(cpms > 1) >= 3 # I have 6 groups, 3 sample replicates and 3 WT replicates
genes_filtered <- DDX39B_exp[keep,]


dim(genes_filtered)
filtered_results <- data.frame(genes_expression = nrow(DDX39B_exp), validGenes = nrow(DDX39B_exp), genes_filtered = nrow(genes_filtered))
rownames(filtered_results)[1] <- "Number of Genes"
filtered_results %>%
  kableExtra::kbl(caption = "Genes count") %>%
  kableExtra::kable_classic(full_width = F, html_font = "Cambria")
```

Data distribution density plot: 

```{r}
data2plot <- log2(edgeR::cpm(genes_filtered[,2:7]))
counts_density <- apply(log2(edgeR::cpm(genes_filtered[,2:7])), 
 2, density)
 #calculate the limits across all the samples
 xlim <- 0; ylim <- 0
 for (i in 1:length(counts_density)) {
 xlim <- range(c(xlim, counts_density[[i]]$x)); 
 ylim <- range(c(ylim, counts_density[[i]]$y))
 }
 cols <- rainbow(length(counts_density))
 ltys <- rep(1, length(counts_density))
 #plot the first density plot to initialize the plot
 plot(counts_density[[1]], xlim=xlim, ylim=ylim, type="n", 
 ylab="Smoothing density of log2-CPM", 
 main="", cex.lab = 0.85)
 #plot each line
 for (i in 1:length(counts_density)) 
 lines(counts_density[[i]], col=cols[i], lty=ltys[i])
 #create legend
 legend("topright", colnames(data2plot), 
 col=cols, lty=ltys, cex=0.75, 
 border ="blue", text.col = "green4", 
 merge = TRUE, bg = "gray90")
```

Data distribution boxplot: 
```{r}

data2plot <- log2(edgeR::cpm(genes_filtered[,2:7]))
boxplot(data2plot, xlab = "Samples", ylab = "log2 CPM", 
 las = 2, cex = 0.5, cex.lab = 0.5,
 cex.axis = 0.5, main = "CA125 RNASeq Samples")
#draw the median on each box plot
abline(h = median(apply(data2plot, 2, median)), 
 col = "green", lwd = 0.6, lty = "dashed")
```

after removing outliers


Normalization by
distribution method

```{r}
limma::plotMA(log2(DDX39B_exp[,c(4,5)]), ylab="M - ratio log expression", 
 main="DDX39B KO + vs WT sample")
```
MDS plot of normalised data
```{r}
filtered_data_matrix <- as.matrix(genes_filtered[,2:7])
rownames(filtered_data_matrix) <- genes_filtered$ensemble_ID
d <- edgeR::DGEList(counts=filtered_data_matrix)
d <- edgeR::calcNormFactors(d) 
normalized_counts <- edgeR::cpm(d)
limma::plotMDS(normalized_counts,
 )
```


```{r}
colnames(normalized_counts)
```


```{r}
library(biomaRt)
```


```{r}

```


To perform mapping, ensembl_gene_id is selected

# ISSUE: when DDX4 file  exists, I don't get conversion stash
```{r}
ensembl <- useMart("ensembl")
ensembl <- useMart(biomart="ensembl", dataset="hsapiens_gene_ensembl")
conversion_stash <- "DDX4_id_conversion.rds"
if(file.exists(conversion_stash)){
  my_id_conversion <- readRDS(conversion_stash)
} else {
  gene_mapped <- getBM(attributes = c("ensembl_gene_id","hgnc_symbol"), filters = c("ensembl_gene_id"), values=genes_filtered$ensemble_ID, mart = ensembl)
  saveRDS(gene_mapped, conversion_stash)
}
```


```{r}
genes_filtered$ensemble_ID[1:10]
```


Total number of genes with measurements
```{r}
nrow(cpms)
```
Number of genes that could not be mapped


```{r}
nrow(cpms) - length(which(rownames(cpms) %in%
gene_mapped$ensembl_gene_id)) 
```


Merging raw data and mapped genes
```{r}
cpms_annot <- merge(gene_mapped, normalized_counts,
by.x = 1, by.y = 0, all.y=TRUE)
```

Check ensembl ID missing genes. 43 is not too many (only 43) can still run differential analysis
```{r}
length(ensembl_id_missing_gene <- cpms_annot$ensembl_gene_id[
which(is.na(cpms_annot$hgnc_symbol))])
```


#A2 Starts

```{r}
write.table(cpms_annot,"./data/GSE156543_finalized_normalized_counts_2023.txt", sep = "\t", col.names = TRUE)


```

# Normalized expression data
```{r}
normalized_count_data <- read.table(file=file.path(getwd(),"data", 
                "GSE156543_finalized_normalized_counts_2023.txt"),
                                    header = TRUE,sep = "\t",
                                    stringsAsFactors = FALSE,
                                    check.names=FALSE)
```

visualize expression values
Row name is Ensemble gene IDs
```{r}
heatmap_matrix <- normalized_count_data[,
                        3:ncol(normalized_count_data)]
rownames(heatmap_matrix) <- normalized_count_data$ensembl_gene_id
colnames(heatmap_matrix) <- colnames(normalized_count_data[,
                        3:ncol(normalized_count_data)])
```

```{r}
library(ComplexHeatmap)
library(circlize)
```


Row normalize with scale function
```{r}
heatmap_matrix <- t(scale(t(heatmap_matrix)))
if(min(heatmap_matrix) == 0){
    heatmap_col = colorRamp2(c( 0, max(heatmap_matrix)), 
                             c( "white", "red"))
  } else {
    heatmap_col = colorRamp2(c(min(heatmap_matrix), 0, 
          max(heatmap_matrix)), c("blue", "white", "red"))
  }
current_heatmap <- Heatmap(as.matrix(heatmap_matrix),
      show_row_dend = TRUE,show_column_dend = TRUE, 
      col=heatmap_col,show_column_names = TRUE, 
      show_row_names = FALSE,show_heatmap_legend = TRUE)
```

All genes in expression set
Variability at the WT vs sample level have different gene expression
```{r}
current_heatmap

```


Look at expression data and see difference of expression of the gene
see difference in expression
```{r}
knock_out <- normalized_count_data[3:5]
Wild_type <- normalized_count_data[6:8]

```

NBS plot cluster of KO and WT. WT vs sample clusters together is important in determining its value

# PROBLEM: CAN"T DO limma::plotMDS(heatmap_matrix)
```{r}
rownames(filtered_data_matrix) <- genes_filtered$ensemble_ID
d <- edgeR::DGEList(counts=filtered_data_matrix)
d <- edgeR::calcNormFactors(d) 
normalized_counts <- edgeR::cpm(d)
limma::plotMDS(normalized_counts,
 )
```


```{r}

samples <- data.frame(
        lapply(colnames(normalized_count_data)[3:8], 
        FUN=function(x){
          unlist(strsplit(x, split = "\\."))[c(2,3)]}))
colnames(samples) <- colnames(normalized_count_data)[3:8]
rownames(samples) <- c("patients","cell_type2")
samples <- data.frame(t(samples))

samples <- tibble::rownames_to_column(samples, "cell_type")

```

Expression is only controlled by WT or KO the origin of the cell does not effect my data as seen in limma graph
```{r}
model_design <- model.matrix(~ samples$cell_type )
kable(model_design[1:5,], type="html")
```


```{r}
expressionMatrix <- as.matrix(normalized_count_data[,3:8])
rownames(expressionMatrix) <- 
  normalized_count_data$ensembl_gene_id
colnames(expressionMatrix) <- 
  colnames(normalized_count_data)[3:8]
minimalSet <- Biobase::ExpressionSet(assayData=expressionMatrix)
```

# How to do model design??
Fit data to the model
```{r}
fit <- limma::lmFit(minimalSet, model_design)

```
Top hits for this expression, order according to p value
Perform differntial expression and associate with p-values.
Get all of the top hists associated with expression
Use Benjamin Hoffberger method for adjustment. 
```{r}
fit2 <- limma::eBayes(fit,trend=TRUE)
# adjust model for multiple hypothesis testing
topfit <- topTable(fit2, 
                   coef=ncol(model_design),
                   adjust.method = "BH",
                   number = nrow(expressionMatrix))
#merge hgnc names to topfit table add ENSG and gen ID to output
output_hits <- merge(normalized_count_data[,1:2],
                     topfit,
                     by.y=0,by.x=1,
                     all.y=TRUE)
#sort by pvalue
output_hits <- output_hits[order(output_hits$P.Value),]
```

Get our top 10 hits, including the p-values, hgnc symbol names, logFC between WT and KO states
Avg expression, t-value for t-test, p-value, and adjusted p-value
```{r}
kable(output_hits[1:10,2:8],type="html",row.names = FALSE)

```


The number of genes that pass the threshold of 0.5 p-value, the more the better
Need to account for biological model if there is only a few of these significant genes. 
```{r}
length(which(output_hits$P.Value < 0.05))

```

Number of genes that pass the correction
correct for randomness
```{r}
length(which(output_hits$adj.P.Val < 0.05))

```

heatmap for just significant differentially expressed genes
# Do I need to serach for only 1 gene like MUC16? Yes, I will do BRCA2
```{r}
#p-value less than 0.05
top_hits <- output_hits$ensembl_gene_id[
  output_hits$P.Value<0.05]
heatmap_matrix_tophits <- t(
  scale(t(heatmap_matrix[
    which(rownames(heatmap_matrix) %in% top_hits),])))
if(min(heatmap_matrix_tophits) == 0){
    heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)), 
                             c( "white", "red"))
  } else {
    heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
      max(heatmap_matrix_tophits)), c("blue", "white", "red"))
  }
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                               show_row_dend = TRUE,
                               show_column_dend = TRUE, 
                               col=heatmap_col,
                               show_column_names = TRUE, 
                               show_row_names = FALSE,
                               show_heatmap_legend = TRUE,
                               )
```


Keep the WT and KO together
Are there blocks of genes present in WT vs KO? 
Are there similar expression with respect to the genes? 
```{r}
heatmap_matrix_tophits<- heatmap_matrix_tophits[, 
    c(grep(colnames(heatmap_matrix_tophits),
                          pattern = "WT"),
      grep(colnames(heatmap_matrix_tophits),
                          pattern = "KO"))]
if(min(heatmap_matrix_tophits) == 0){
    heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)), 
                             c( "white", "red"))
  } else {
    heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0,
                    max(heatmap_matrix_tophits)), 
                    c("blue", "white", "red"))
  }
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
                           cluster_rows = TRUE,
                           cluster_columns = FALSE,
                               show_row_dend = TRUE,
                               show_column_dend = TRUE, 
                               col=heatmap_col,
                               show_column_names = TRUE, 
                               show_row_names = FALSE,
                               show_heatmap_legend = TRUE,
                               )
```


Using edgeR for calculating differential Expression for RNAseq

can use models to score for diff exp
Recommended to use Quasi for bulk RNA seq, 
```{r}
#setup edgeR object
d = DGEList(counts=filtered_data_matrix, group=samples$cell_type)
#estimate dispersion
d <- estimateDisp(d, model_design)

#fit model
fit <- glmQLFit(d, model_design)

kable(model_design, type="html") %>%
  row_spec(0, angle = -45)

```

Do differential expression grab the top hists
logCPM 
p-value
logFC of WT and KO cells
```{r}
#Choose sample KO
qlf.pos_vs_neg <- glmQLFTest(fit, coef='samples$cell_typeKO')
kable(topTags(qlf.pos_vs_neg), type="html",row.names = FALSE)
```

Number of genes that pass 0.05 threshold
```{r}
qlf_output_hits <- topTags(qlf.pos_vs_neg,sort.by = "PValue",
                           n = nrow(normalized_count_data))

length(which(qlf_output_hits$table$PValue < 0.05))

length(which(qlf_output_hits$table$FDR < 0.05))

```


edgeR (better since for RNAseq data) vs limma
```{r}
qlf_model_pvalues <- data.frame(
          ensembl_id = rownames(qlf_output_hits$table),
          qlf_pvalue=qlf_output_hits$table$PValue)
limma_model_pvalues <-  data.frame(
          ensembl_id = output_hits_pat$ensembl_gene_id,
          limma_pvalue = output_hits_pat$P.Value)
two_models_pvalues <- merge(qlf_model_pvalues,
                            limma_model_pvalues,
                            by.x=1,by.y=1)
two_models_pvalues$colour <- "black"
two_models_pvalues$colour[two_models_pvalues$qlf_pvalue
                          <0.05] <- "orange"
two_models_pvalues$colour[two_models_pvalues$limma_pvalue
                          <0.05] <- "blue"
two_models_pvalues$colour[two_models_pvalues$qlf_pvalue
                          <0.05 &                            
two_models_pvalues$limma_pvalue<0.05] <- "red"
plot(two_models_pvalues$qlf_pvalue,
     two_models_pvalues$limma_pvalue,
     col = two_models_pvalues$colour,
     xlab = "QLF model p-values",
     ylab ="Limma model p-values",
     main="QLF vs limma")
```

heatmap using QLF data 
# I am looking for the WT and KO top hits
```{r}
top_hits <- rownames(qlf_output_hits$table)[output_hits$P.Value
                                            <0.05] 
heatmap_matrix_tophits <- t(
  scale(t(heatmap_matrix[which(rownames(heatmap_matrix) 
                               %in% top_hits),]))) 
heatmap_matrix_tophits<- heatmap_matrix_tophits[,
  c(grep(colnames(heatmap_matrix_tophits),pattern = "WT"),
    grep(colnames(heatmap_matrix_tophits),pattern = "KO"))]
if(min(heatmap_matrix_tophits) == 0){
    heatmap_col = colorRamp2(c( 0, max(heatmap_matrix_tophits)), 
                             c( "white", "red"))
  } else {
    heatmap_col = colorRamp2(c(min(heatmap_matrix_tophits), 0, 
                               max(heatmap_matrix_tophits)), 
                             c("blue", "white", "red"))
  }
current_heatmap <- Heatmap(as.matrix(heatmap_matrix_tophits),
                           cluster_rows = TRUE,
                           cluster_columns = FALSE,
                               show_row_dend = TRUE,
                               show_column_dend = FALSE,
                               col=heatmap_col,
                               show_column_names = TRUE, 
                               show_row_names = FALSE,
                               show_heatmap_legend = TRUE)
```




# References

